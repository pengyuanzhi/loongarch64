#define ASM_USE

#include <cpu.h>
#include <asm.h>
#incldue <asrspace.h>

    .text
    .align  5
ENTRY(handle_syscall)
    move        t2, sp

    /* 系统调用来自用户空间，所以需要修改sp寄存器的值为当前运行任务的内核栈 */
#ifdef CONFIG_SMP
    csrrd     t0, LOONGARCH_CSR_CPUID
    li.w      t1, __SIZEOF_POINTER__
    mul.w     t0, t0, t1
#endif
	la_abs	  t1, running_task_stack
#ifdef CONFIG_SMP
    LONG_ADD  t1, t1, t0
#endif
	LONG_L	  sp, t1, 0

    addi.d      sp, sp, -PT_SIZE        /* 在栈中开辟一个内存块用于存放发起系统调用的上下文的内容，数据类型为 struct arch_context/arch_int_context_t/arch_exception_context_t */
    LONG_S      zero, sp, PT_R0         /* 存储常量0寄存器    r0 */
    LONG_S      ra, sp, PT_R1           /* 存储返回地址寄存器 r1 ，即发起系统调用的函数的返回地址 */
    LONG_S      tp, sp, PT_R2           /* 存储线程指针寄存器 r2 ，即发起系统调用的线程的指针 */
    LONG_S      t2, sp, PT_R3           /* 存储之前（刚进入异常时）的栈指针 r3 ，即发起系统调用的线程的栈指针 */
    LONG_S      a0, sp, PT_R4           /* 存储返回值/第1个参数寄存器 r4 ，即系统调用的参数1 */
    LONG_S      a1, sp, PT_R5           /* 存储返回值/第2个参数寄存器 r5 ，即系统调用的参数2 */
    LONG_S      a2, sp, PT_R6           /* 存储第3个参数寄存器 r6 ，即系统调用的参数3 */
    LONG_S      a3, sp, PT_R7           /* 存储第4个参数寄存器 r7 ，即系统调用的参数4 */
    LONG_S      a4, sp, PT_R8           /* 存储第5个参数寄存器 r8 ，即系统调用的参数5 */
    LONG_S      a5, sp, PT_R9           /* 存储第6个参数寄存器 r9 ，即系统调用的参数6 */
    LONG_S      a6, sp, PT_R10          /* 存储第7个参数寄存器 r10 ，即系统调用的参数7 */
    LONG_S      a7, sp, PT_R11          /* 存储第8个参数寄存器 r11 ，即系统调用号 */

    /* 这里的 t0 ~ t8 （r12~r20） 寄存器不用保存，因为它们是调用者保存的寄存器
       这时的 t0 ~ t8 寄存器的值是多少，就看当前sp指向的栈中保存对应 t0 ~ t8 寄存器的值是多少了
     */

    LONG_S      u0, sp, PT_R21          /* 存储保留寄存器 r21 */
    LONG_S      fp, sp, PT_R22          /* 存储栈帧指针/静态寄存器 r22 */

    SAVE_STATIC                         /* 存储静态寄存器 r23~r31 */

    csrrd       ra, LOONGARCH_CSR_ERA
    LONG_S      ra, sp, PT_ERA          /* 存储例外返回地址寄存器 csr_era ，即执行系统调用指令的地址 */

    csrrd       t2, LOONGARCH_CSR_CRMD
    LONG_S      t2, sp, PT_CRMD         /* 存储当前模式信息寄存器 csr_crmd */
    csrrd       t2, LOONGARCH_CSR_PRMD

    LONG_S      t2, sp, PT_PRMD         /* 存储例外前信息寄存器 csr_prmd */
    csrrd       t2, LOONGARCH_CSR_EUEN
    LONG_S      t2, sp, PT_EUEN         /* 存储扩展部件使能寄存器 csr_euen */
    csrrd       t2, LOONGARCH_CSR_ECFG
    LONG_S      t2, sp, PT_ECFG         /* 存储例外配置寄存器 csr_ecfg */
    csrrd       t2, LOONGARCH_CSR_ESTAT
    LONG_S      t2, sp, PT_ESTAT        /* 存储例外状态寄存器 csr_estat */

#ifdef CONFIG_KGDB
    li.w        t1, CSR_CRMD_WE
    csrxchg     t1, t1, LOONGARCH_CSR_CRMD
#endif

/*  move        u0, t0 */                 /* 保存当前CPU变量基址的偏移到 u0/r21 寄存器 */

    /* TODO:jcai 这里为何这样做？ */
/*  li.d        tp, ~_THREAD_MASK */
    /*and           tp, tp, sp */

    move        a0, sp
    bl          do_syscall

    RESTORE_ALL_AND_RET                 /* 恢复进入系统调用异常前的上下文，并返回进入系统调用的上下文 */
ENDPROC(handle_syscall)
