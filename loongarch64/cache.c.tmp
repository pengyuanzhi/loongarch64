/**
 * @file    cache.c
 * @brief   LoongArch64缓存操作实现
 * @author  AISafe64 Team
 * @date    2025-01-21
 * @version 1.0
 *
 * @details 本文件实现了LoongArch64缓存操作相关功能
 *          - 指令缓存(ICache)操作
 *          - 数据缓存(DCache)操作
 *          - 缓存一致性维护
 *
 * @note MISRA-C:2012 合规
 * @note LoongArch硬件维护ICache/DCache一致性
 * @warning 多核环境下需要使用内存屏障确保缓存一致性
 *
 * @copyright Copyright (c) 2025 AISafe64 Team
 */

/************************头 文 件******************************/
#include <stddef.h>
#include <stdint.h>
#include <system/macros.h>
#include <system/types.h>
#include <util.h>
#include <cpu.h>

/************************宏 定 义******************************/
/************************类型定义******************************/
/************************全局变量******************************/

/************************外部声明******************************/
void cache_dcache_flush(size_t vaddr_start, size_t len);

/************************函数实现******************************/

/**
 * @brief 更新指令缓存
 *
 * @details 刷新指令缓存以确保代码更改生效
 *          使用ibar指令避免指令冒险
 *
 * @param vaddr_start 虚拟地址起始
 * @param len         更新长度（字节）
 *
 * @return 无
 *
 * @note LoongArch硬件维护ICache/DCache一致性
 * @note 仅需要ibar指令避免指令冒险
 */
void cache_text_update(size_t vaddr_start, size_t len)
{
    (void)vaddr_start;
    (void)len;
    __asm__ volatile("\tibar 0\n" ::: "memory");
}

/**
 * @brief 刷新本地指令缓存范围
 *
 * @details 刷新指定范围的指令缓存
 *          使用ibar指令确保指令一致性
 *
 * @param start 起始虚拟地址
 * @param end   结束虚拟地址
 *
 * @return 无
 *
 * @note LoongArch硬件维护ICache/DCache一致性
 * @note 仅需要ibar指令避免指令冒险
 */
void local_flush_icache_range(unsigned long start, unsigned long end)
{
    (void)start;
    (void)end;
    __asm__ volatile("\tibar 0\n" ::: "memory");
}

/**
 * @brief 刷新所有数据缓存
 *
 * @details 将所有脏数据写回内存
 *          使用dbar指令确保数据一致性
 *
 * @param 无
 *
 * @return 成功返回0
 *
 * @note dbar指令完成数据缓存屏障
 */
int arch_dcache_flush_all(void)
{
    __asm__ volatile("\tdbar 0\n" ::: "memory");
    return 0;
}

/**
 * @brief 使所有数据缓存无效
 *
 * @details 使所有数据缓存条目无效
 *          使用dbar指令确保数据一致性
 *
 * @param 无
 *
 * @return 成功返回0
 *
 * @note dbar指令完成数据缓存屏障
 */
int arch_dcache_invd_all(void)
{
    __asm__ volatile("\tdbar 0\n" ::: "memory");
    return 0;
}

/**
 * @brief 刷新并使所有数据缓存无效
 *
 * @details 将所有脏数据写回内存并使缓存无效
 *          使用dbar指令确保数据一致性
 *
 * @param 无
 *
 * @return 成功返回0
 *
 * @note dbar指令完成数据缓存屏障
 */
int dcache_flush_and_invd_all(void)
{
    __asm__ volatile("\tdbar 0\n" ::: "memory");
    return 0;
}

/**
 * @brief 使指定范围的数据缓存无效
 *
 * @details 使指定地址范围的数据缓存无效
 *
 * @param start_addr 起始虚拟地址
 * @param size       大小（字节）
 *
 * @return 成功返回0
 *
 * @note 当前实现调用cache_dcache_flush
 */
int dcache_invd_range(void *start_addr, size_t size)
{
    cache_dcache_flush((size_t)start_addr, size);
    return 0;
}

/**
 * @brief 刷新并使指定范围的数据缓存无效
 *
 * @details 将指定范围的脏数据写回内存并使缓存无效
 *          使用dbar指令确保数据一致性
 *
 * @param start_addr 起始虚拟地址
 * @param size       大小（字节）
 *
 * @return 成功返回0
 *
 * @note dbar指令完成数据缓存屏障
 */
int arch_dcache_flush_and_invd_range(void *start_addr, size_t size)
{
    (void)start_addr;
    (void)size;
    __asm__ volatile("\tdbar 0\n" ::: "memory");
    return 0;
}

/**
 * @brief 使指定范围的数据缓存无效
 *
 * @details 使指定地址范围的数据缓存无效
 *
 * @param vaddr_start 起始虚拟地址
 * @param len         长度（字节）
 *
 * @return 无
 *
 * @note 当前实现调用cache_dcache_flush
 */
void cache_dcache_invalidate(size_t vaddr_start, size_t len)
{
    cache_dcache_flush(vaddr_start, len);
}

/**
 * @brief 清理所有数据缓存
 *
 * @details 将所有脏数据写回内存
 *          使用dbar指令确保数据一致性
 *
 * @param 无
 *
 * @return 无
 *
 * @note dbar指令完成数据缓存屏障
 */
void cache_dcache_clean_all(void)
{
    __asm__ volatile("\tdbar 0\n" ::: "memory");
}

/**
 * @brief 清理指定范围的数据缓存
 *
 * @details 将指定范围的脏数据写回内存
 *          使用dbar指令确保数据一致性
 *
 * @param vaddr_start 起始虚拟地址
 * @param len         长度（字节）
 *
 * @return 无
 *
 * @note dbar指令完成数据缓存屏障
 */
void cache_dcache_clean(size_t vaddr_start, size_t len)
{
    (void)vaddr_start;
    (void)len;
    __asm__ volatile("\tdbar 0\n" ::: "memory");
}

/**
 * @brief 刷新指定范围的数据缓存
 *
 * @details 刷新指定地址范围的数据缓存
 *          使用dbar指令确保数据一致性
 *
 * @param vaddr_start 起始虚拟地址
 * @param len         长度（字节）
 *
 * @return 无
 *
 * @note dbar指令完成数据缓存屏障
 * @note 此函数为缓存刷新的基本操作
 */
void cache_dcache_flush(size_t vaddr_start, size_t len)
{
    (void)vaddr_start;
    (void)len;
    __asm__ volatile("\tdbar 0\n" ::: "memory");
}
